<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>Socket</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" href="../css/reset.css" type="text/css" media="screen" />
    <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" />
    <script src="../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
    <script src="../js/main.js" type="text/javascript" charset="utf-8"></script>
</head>

<body>     
    <div class="banner">
        <h1>
            <span class="type">Class</span> 
            Socket 
            
                <span class="parent">&lt; 
                    
                    <a href="Object.html">Object</a>
                    
                </span>
            
        </h1>
        <ul class="files">
            
            <li><a href="../files/lib/ipaddr_rb.html">lib/ipaddr.rb</a></li>
            
            <li><a href="../files/ext/socket/socket_c.html">ext/socket/socket.c</a></li>
            
        </ul>
    </div>
    <div id="bodyContent">
        <div id="content">
    
    <div class="description">
        <p>
<a href="Socket.html">Socket</a> contains a number of generally useful
singleton methods and constants, as well as offering low-level interfaces
that can be used to develop socket applications using protocols other than
TCP, UDP, and UNIX domain sockets.
</p>

    </div>
    

    

    
    

    
    
    <div class="sectiontitle">Methods</div>
    <dl class="methods">
    
        <dt>A</dt>
        <dd>
            <ul>
                
                <li><a href="#M007157">accept</a>,</li>
                
                <li><a href="#M007158">accept_nonblock</a></li>
                
            </ul>
        </dd>
    
        <dt>B</dt>
        <dd>
            <ul>
                
                <li><a href="#M007155">bind</a></li>
                
            </ul>
        </dd>
    
        <dt>C</dt>
        <dd>
            <ul>
                
                <li><a href="#M007153">connect</a>,</li>
                
                <li><a href="#M007154">connect_nonblock</a></li>
                
            </ul>
        </dd>
    
        <dt>G</dt>
        <dd>
            <ul>
                
                <li><a href="#M007169">getaddrinfo</a>,</li>
                
                <li><a href="#M007166">gethostbyname</a>,</li>
                
                <li><a href="#M007168">getservbyname</a></li>
                
            </ul>
        </dd>
    
        <dt>L</dt>
        <dd>
            <ul>
                
                <li><a href="#M007156">listen</a></li>
                
            </ul>
        </dd>
    
        <dt>R</dt>
        <dd>
            <ul>
                
                <li><a href="#M007160">recvfrom</a>,</li>
                
                <li><a href="#M007161">recvfrom_nonblock</a></li>
                
            </ul>
        </dd>
    
        <dt>S</dt>
        <dd>
            <ul>
                
                <li><a href="#M007159">sysaccept</a></li>
                
            </ul>
        </dd>
    
    </dl>
    

    

    

    
    <div class="sectiontitle">Classes and Modules</div>
    <ul>
        
        <li><span class="type">MODULE</span> <a href="Socket/Constants.html">Socket::Constants</a></li>
        
    </ul>
    

    
    <div class="sectiontitle">Constants</div>
    <table border='0' cellpadding='5'>
        
        <tr valign='top'>
            <td class="attr-name">AF_INET6</td>
            <td>=</td>
            <td class="attr-value">Object.new</td>
        </tr>
        
        
    </table>
    

    

    
            <div class="sectiontitle">Class Public methods</div>
            
            <div class="method">
                <div class="title" id="M007169">
                    
                    <a name="M007169"></a><b> Socket.getaddrinfo(host, service, family=nil, socktype=nil, protocol=nil, flags=nil) => addrinfo
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Return address information for <tt>host</tt> and <tt>port</tt>. The
remaining arguments are hints that limit the address information returned.
</p>
<p>
This method corresponds closely to the POSIX.1g getaddrinfo() definition.
</p>
<h3>Parameters</h3>
<ul>
<li><tt>host</tt> is a host name or an address string (dotted decimal for IPv4,
or a hex string for IPv6) for which to return information. A nil is also
allowed, its meaning depends on <tt>flags</tt>, see below.

</li>
<li><tt>service</tt> is a service name (&#8220;http&#8221;, &#8220;ssh&#8221;,
&#8230;), or a port number (80, 22, &#8230;), see <a
href="Socket.html#M007168">Socket.getservbyname</a> for more information. A
nil is also allowed, meaning zero.

</li>
<li><tt>family</tt> limits the output to a specific address family, one of the
Socket::AF_* constants. Socket::AF_INET (IPv4) and Socket::AF_INET6 (IPv6)
are the most commonly used families. You will usually pass either nil or
Socket::AF_UNSPEC, allowing the IPv6 information to be returned first if
<tt>host</tt> is reachable via IPv6, and IPv4 information otherwise. The
two strings &#8220;AF_INET&#8220; or &#8220;<a
href="Socket.html#AF_INET6">AF_INET6</a>&#8220; are also allowed, they are
converted to their respective Socket::AF_* constants.

</li>
<li><tt>socktype</tt> limits the output to a specific type of socket, one of
the Socket::SOCK_* constants. Socket::SOCK_STREAM (for TCP) and
Socket::SOCK_DGRAM (for UDP) are the most commonly used socket types. If
nil, then information for all types of sockets supported by
<tt>service</tt> will be returned. You will usually know what type of
socket you intend to create, and should pass that socket type in.

</li>
<li><tt>protocol</tt> limits the output to a specific protocol numpber, one of
the Socket::IPPROTO_* constants. It is usually implied by the socket type
(Socket::SOCK_STREAM => Socket::IPPROTO_TCP, &#8230;), if you pass other
than nil you already know what this is for.

</li>
<li><tt>flags</tt> is one of the Socket::AI_* constants. They mean:

<ul>
<li>Socket::AI_PASSIVE: when set, if <tt>host</tt> is nil the &#8216;any&#8217;
address will be returned, Socket::INADDR_ANY or 0 for IPv4,
&#8220;0::0&#8221; or &#8220;::&#8221; for IPv6. This address is suitable
for use by servers that will bind their socket and do a passive listen,
thus the name of the flag. Otherwise the local or loopback address will be
returned, this is &#8220;127.0.0.1&#8220; for IPv4 and &#8220;::1&#8217;
for IPv6.

</li>
<li>&#8230;

</li>
</ul>
</li>
</ul>
<h3>Returns</h3>
<p>
Returns an array of arrays, where each subarray contains:
</p>
<ul>
<li>address family, a string like &#8220;AF_INET&#8220; or &#8220;<a
href="Socket.html#AF_INET6">AF_INET6</a>&#8220;

</li>
<li>port number, the port number for <tt>service</tt>

</li>
<li>host name, either a canonical name for <tt>host</tt>, or it&#8217;s address
in presentation format if the address could not be looked up.

</li>
<li>host IP, the address of <tt>host</tt> in presentation format

</li>
<li>address family, as a numeric value (one of the Socket::AF_* constants).

</li>
<li>socket type, as a numeric value (one of the Socket::SOCK_* constants).

</li>
<li>protocol number, as a numeric value (one of the Socket::IPPROTO_*
constants).

</li>
</ul>
<p>
The first four values are identical to what is commonly returned as an
address array, see <a href="IPSocket.html">IPSocket</a> for more
information.
</p>
<h3>Examples</h3>
<p>
Not all input combinations are valid, and while there are many
combinations, only a few cases are common.
</p>
<p>
A typical client will call getaddrinfo with the <tt>host</tt> and
<tt>service</tt> it wants to connect to. It knows that it will attempt to
connect with either TCP or UDP, and specifies <tt>socktype</tt>
accordingly. It loops through all returned addresses, and try to connect to
them in turn:
</p>
<pre>
  addrinfo = Socket::getaddrinfo('www.example.com', 'www', nil, Socket::SOCK_STREAM)
  addrinfo.each do |af, port, name, addr|
    begin
      sock = TCPSocket.new(addr, port)
      # ...
      exit 1
    rescue
    end
  end
</pre>
<p>
With UDP you don&#8217;t know if connect suceeded, but if communication
fails, the next address can be tried.
</p>
<p>
A typical server will call getaddrinfo with a <tt>host</tt> of nil, the
<tt>service</tt> it listens to, and a <tt>flags</tt> of Socket::AI_PASSIVE.
It will listen for connections on the first returned address:
</p>
<pre>
  addrinfo = Socket::getaddrinfo(nil, 'www', nil, Socket::SOCK_STREAM, nil, Socket::AI_PASSIVE)
  af, port, name, addr = addrinfo.first
  sock = TCPServer(addr, port)
  while( client = s.accept )
    # ...
  end
</pre>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M007169_source')" id="l_M007169_source">show</a>
                        
                    </p>
                    <div id="M007169_source" class="dyn-source">
                        <pre>static VALUE
sock_s_getaddrinfo(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE host, port, family, socktype, protocol, flags, ret;
    char hbuf[1024], pbuf[1024];
    char *hptr, *pptr, *ap;
    struct addrinfo hints, *res;
    int error;

    host = port = family = socktype = protocol = flags = Qnil;
    rb_scan_args(argc, argv, &quot;24&quot;, &amp;host, &amp;port, &amp;family, &amp;socktype, &amp;protocol, &amp;flags);
    if (NIL_P(host)) {
        hptr = NULL;
    }
    else {
        strncpy(hbuf, StringValuePtr(host), sizeof(hbuf));
        hbuf[sizeof(hbuf) - 1] = '\0';
        hptr = hbuf;
    }
    if (NIL_P(port)) {
        pptr = NULL;
    }
    else if (FIXNUM_P(port)) {
        snprintf(pbuf, sizeof(pbuf), &quot;%ld&quot;, FIX2LONG(port));
        pptr = pbuf;
    }
    else {
        strncpy(pbuf, StringValuePtr(port), sizeof(pbuf));
        pbuf[sizeof(pbuf) - 1] = '\0';
        pptr = pbuf;
    }

    MEMZERO(&amp;hints, struct addrinfo, 1);
    if (NIL_P(family)) {
        hints.ai_family = PF_UNSPEC;
    }
    else if (FIXNUM_P(family)) {
        hints.ai_family = FIX2INT(family);
    }
    else if ((ap = StringValuePtr(family)) != 0) {
        if (strcmp(ap, &quot;AF_INET&quot;) == 0) {
            hints.ai_family = PF_INET;
        }
#ifdef INET6
        else if (strcmp(ap, &quot;AF_INET6&quot;) == 0) {
            hints.ai_family = PF_INET6;
        }
#endif
    }

    if (!NIL_P(socktype)) {
        hints.ai_socktype = NUM2INT(socktype);
    }
    if (!NIL_P(protocol)) {
        hints.ai_protocol = NUM2INT(protocol);
    }
    if (!NIL_P(flags)) {
        hints.ai_flags = NUM2INT(flags);
    }
    error = getaddrinfo(hptr, pptr, &amp;hints, &amp;res);
    if (error) {
        rb_raise(rb_eSocket, &quot;getaddrinfo: %s&quot;, gai_strerror(error));
    }

    ret = make_addrinfo(res);
    freeaddrinfo(res);
    return ret;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M007166">
                    
                    <a name="M007166"></a><b> Socket.gethostbyname(host) => hostent
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Resolve <tt>host</tt> and return name and address information for it,
similarly to gethostbyname(3). <tt>host</tt> can be a domain name or the
presentation format of an address.
</p>
<p>
Returns an array of information similar to that found in a +struct
hostent+:
</p>
<pre>
  - cannonical name: the cannonical name for host in the DNS, or a
    string representing the address
  - aliases: an array of aliases for the canonical name, there may be no aliases
  - address family: usually one of Socket::AF_INET or Socket::AF_INET6
  - address: a string, the binary value of the +struct sockaddr+ for this name, in
    the indicated address family
  - ...: if there are multiple addresses for this host,  a series of
    strings/+struct sockaddr+s may follow, not all necessarily in the same
    address family. Note that the fact that they may not be all in the same
    address family is a departure from the behaviour of gethostbyname(3).
</pre>
<p>
Note: I believe that the fact that the multiple addresses returned are not
necessarily in the same address family may be a bug, since if this function
actually called gethostbyname(3), ALL the addresses returned in the
trailing address list (h_addr_list from struct hostent) would be of the
same address family! Examples from my system, OS X 10.3:
</p>
<pre>
  [&quot;localhost&quot;, [], 30, &quot;\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001&quot;, &quot;\177\000\000\001&quot;]
    and
  [&quot;ensemble.local&quot;, [], 30, &quot;\376\200\000\004\000\000\000\000\002\003\223\377\376\255\010\214&quot;, &quot;\300\250{\232&quot; ]
</pre>
<p>
Similar information can be returned by <a
href="Socket.html#M007169">Socket.getaddrinfo</a> if called as:
</p>
<pre>
   Socket.getaddrinfo(+host+, 0, Socket::AF_UNSPEC, Socket::SOCK_STREAM, nil, Socket::AI_CANONNAME)
</pre>
<h2>Examples</h2>
<pre>
  Socket.gethostbyname &quot;example.com&quot;
  =&gt; [&quot;example.com&quot;, [], 2, &quot;\300\000\&quot;\246&quot;]
</pre>
<p>
This name has no DNS aliases, and a single IPv4 address.
</p>
<pre>
  Socket.gethostbyname &quot;smtp.telus.net&quot;
  =&gt; [&quot;smtp.svc.telus.net&quot;, [&quot;smtp.telus.net&quot;], 2, &quot;\307\271\334\371&quot;]
</pre>
<p>
This name is an an alias so the canonical name is returned, as well as the
alias and a single IPv4 address.
</p>
<pre>
  Socket.gethostbyname &quot;localhost&quot;
  =&gt; [&quot;localhost&quot;, [], 30, &quot;\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\001&quot;, &quot;\177\000\000\001&quot;]
</pre>
<p>
This machine has no aliases, returns an IPv6 address, and has an additional
IPv4 address.
</p>
<p>
<tt>host</tt> can also be an IP address in presentation format, in which
case a reverse lookup is done on the address:
</p>
<pre>
  Socket.gethostbyname(&quot;127.0.0.1&quot;)
  =&gt; [&quot;localhost&quot;, [], 2, &quot;\177\000\000\001&quot;]

  Socket.gethostbyname(&quot;192.0.34.166&quot;)
  =&gt; [&quot;www.example.com&quot;, [], 2, &quot;\300\000\&quot;\246&quot;]
</pre>
<h2>See</h2>
<p>
See: <a href="Socket.html#M007169">Socket.getaddrinfo</a>
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M007166_source')" id="l_M007166_source">show</a>
                        
                    </p>
                    <div id="M007166_source" class="dyn-source">
                        <pre>static VALUE
sock_s_gethostbyname(obj, host)
    VALUE obj, host;
{
    rb_secure(3);
    return make_hostent(host, sock_addrinfo(host, Qnil, SOCK_STREAM, AI_CANONNAME), sock_sockaddr);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M007168">
                    
                    <a name="M007168"></a><b> Socket.getservbyname(name, proto="tcp") => port
</b>
                    
                </div>
                
                <div class="description">
                  <p>
<tt>name</tt> is a service name (&#8220;ftp&#8221;, &#8220;telnet&#8221;,
&#8230;) and proto is a protocol name (&#8220;udp&#8221;,
&#8220;tcp&#8221;, &#8230;). &#8216;/etc/services&#8217; (or your
system&#8217;s equivalent) is searched for a service for <tt>name</tt> and
<tt>proto</tt>, and the port number is returned.
</p>
<p>
Note that unlike <a href="Socket.html#M007169">Socket.getaddrinfo</a>,
<tt>proto</tt> may not be specified using the Socket::SOCK_* constants, a
string must must be used.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M007168_source')" id="l_M007168_source">show</a>
                        
                    </p>
                    <div id="M007168_source" class="dyn-source">
                        <pre>static VALUE
sock_s_getservbyaname(argc, argv)
    int argc;
    VALUE *argv;
{
    VALUE service, proto;
    struct servent *sp;
    int port;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;service, &amp;proto);
    if (NIL_P(proto)) proto = rb_str_new2(&quot;tcp&quot;);
    StringValue(service);
    StringValue(proto);

    sp = getservbyname(StringValueCStr(service),  StringValueCStr(proto));
    if (sp) {
        port = ntohs(sp-&gt;s_port);
    }
    else {
        char *s = RSTRING(service)-&gt;ptr;
        char *end;

        port = strtoul(s, &amp;end, 0);
        if (*end != '\0') {
            rb_raise(rb_eSocket, &quot;no such service %s/%s&quot;, s, RSTRING(proto)-&gt;ptr);
        }
    }
    return INT2FIX(port);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="sectiontitle">Instance Public methods</div>
            
            <div class="method">
                <div class="title" id="M007157">
                    
                    <a name="M007157"></a><b>socket.accept => [ socket, string ]
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Accepts an incoming connection returning an array containing a new <a
href="Socket.html">Socket</a> object and a string holding the
<tt>struct</tt> sockaddr information about the caller.
</p>
<h3>Example</h3>
<pre>
     # In one script, start this first
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.bind( sockaddr )
     socket.listen( 5 )
     client, client_sockaddr = socket.accept
     puts &quot;The client said, '#{client.readline.chomp}'&quot;
     client.puts &quot;Hello from script one!&quot;
     socket.close

     # In another script, start this second
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.connect( sockaddr )
     socket.puts &quot;Hello from script 2.&quot;
     puts &quot;The server said, '#{socket.readline.chomp}'&quot;
     socket.close
</pre>
<h3>Unix-based Exceptions</h3>
<p>
On unix-based based systems the following system exceptions may be raised
if the call to <em>accept</em> fails:
</p>
<ul>
<li>Errno::EAGAIN - O_NONBLOCK is set for the <tt>socket</tt> file descriptor
and no connections are parent to be accepted

</li>
<li>Errno::EWOULDBLOCK - same as Errno::EAGAIN

</li>
<li>Errno::EBADF - the <tt>socket</tt> is not a valid file descriptor

</li>
<li>Errno::ECONNABORTED - a connection has been aborted

</li>
<li>Errno::EFAULT - the socket&#8217;s internal address or address length
parameter cannot be access or written

</li>
<li>Errno::EINTR - the <em>accept</em> method was interrupted by a signal that
was caught before a valid connection arrived

</li>
<li>Errno::EINVAL - the <tt>socket</tt> is not accepting connections

</li>
<li>Errno::EMFILE - OPEN_MAX file descriptors are currently open in the calling
process

</li>
<li>Errno::ENOBUFS - no buffer space is available

</li>
<li>Errno::ENOMEM - there was insufficient memory available to complete the
operation

</li>
<li>Errno::ENOSR - there was insufficient STREAMS resources available to
complete the operation

</li>
<li>Errno::ENFILE - the maximum number of file descriptors in the system are
already open

</li>
<li>Errno::ENOTSOCK - the <tt>socket</tt> does not refer to a socket

</li>
<li>Errno::EOPNOTSUPP - the socket type for the calling <tt>socket</tt> does
not support accept connections

</li>
<li>Errno::EPROTO - a protocol error has occurred

</li>
</ul>
<h3>Windows Exceptions</h3>
<p>
On Windows systems the following system exceptions may be raised if the
call to <em>accept</em> fails:
</p>
<ul>
<li>Errno::ECONNRESET - an incoming connection was indicated, but was
terminated by the remote peer prior to accepting the connection

</li>
<li>Errno::EFAULT - the socket&#8217;s internal address or address length
parameter is too small or is not a valid part of the user space address

</li>
<li>Errno::EINVAL - the <em>listen</em> method was not invoked prior to calling
<em>accept</em>

</li>
<li>Errno::EINPROGRESS - a blocking Windows Sockets 1.1 call is in progress or
the service provider is still processing a callback function

</li>
<li>Errno::EMFILE - the queue is not empty, upong etry to <em>accept</em> and
there are no socket descriptors available

</li>
<li>Errno::ENETDOWN - the network is down

</li>
<li>Errno::ENOBUFS - no buffer space is available

</li>
<li>Errno::ENOTSOCK - <tt>socket</tt> is not a socket

</li>
<li>Errno::EOPNOTSUPP - <tt>socket</tt> is not a type that supports
connection-oriented service.

</li>
<li>Errno::EWOULDBLOCK - <tt>socket</tt> is marked as nonblocking and no
connections are present to be accepted

</li>
</ul>
<h3>See</h3>
<ul>
<li>accept manual pages on unix-based systems

</li>
<li>accept function in Microsoft&#8217;s Winsock functions reference

</li>
</ul>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M007157_source')" id="l_M007157_source">show</a>
                        
                    </p>
                    <div id="M007157_source" class="dyn-source">
                        <pre>static VALUE
sock_accept(sock)
    VALUE sock;
{
    rb_io_t *fptr;
    VALUE sock2;
    char buf[1024];
    socklen_t len = sizeof buf;

    GetOpenFile(sock, fptr);
    sock2 = s_accept(rb_cSocket,fileno(fptr-&gt;f),(struct sockaddr*)buf,&amp;len);

    return rb_assoc_new(sock2, rb_str_new(buf, len));
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M007158">
                    
                    <a name="M007158"></a><b>socket.accept_nonblock => [client_socket, client_sockaddr]
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Accepts an incoming connection using accept(2) after O_NONBLOCK is set for
the underlying file descriptor. It returns an array containg the accpeted
socket for the incoming connection, <em>client_socket</em>, and a string
that contains the <tt>struct</tt> sockaddr information about the caller,
<em>client_sockaddr</em>.
</p>
<h3>Example</h3>
<pre>
     # In one script, start this first
     require 'socket'
     include Socket::Constants
     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
     sockaddr = Socket.sockaddr_in(2200, 'localhost')
     socket.bind(sockaddr)
     socket.listen(5)
     begin
       client_socket, client_sockaddr = socket.accept_nonblock
     rescue Errno::EAGAIN, Errno::EWOULDBLOCK, Errno::ECONNABORTED, Errno::EPROTO, Errno::EINTR
       IO.select([socket])
       retry
     end
     puts &quot;The client said, '#{client_socket.readline.chomp}'&quot;
     client_socket.puts &quot;Hello from script one!&quot;
     socket.close

     # In another script, start this second
     require 'socket'
     include Socket::Constants
     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
     sockaddr = Socket.sockaddr_in(2200, 'localhost')
     socket.connect(sockaddr)
     socket.puts &quot;Hello from script 2.&quot;
     puts &quot;The server said, '#{socket.readline.chomp}'&quot;
     socket.close
</pre>
<p>
Refer to <a href="Socket.html#M007157">Socket#accept</a> for the exceptions
that may be thrown if the call to <em><a
href="Socket.html#M007158">accept_nonblock</a></em> fails.
</p>
<p>
<a href="Socket.html#M007158">Socket#accept_nonblock</a> may raise any
error corresponding to accept(2) failure, including Errno::EAGAIN.
</p>
<h3>See</h3>
<ul>
<li><a href="Socket.html#M007157">Socket#accept</a>

</li>
</ul>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M007158_source')" id="l_M007158_source">show</a>
                        
                    </p>
                    <div id="M007158_source" class="dyn-source">
                        <pre>static VALUE
sock_accept_nonblock(sock)
    VALUE sock;
{
    rb_io_t *fptr;
    VALUE sock2;
    char buf[1024];
    socklen_t len = sizeof buf;

    GetOpenFile(sock, fptr);
    sock2 = s_accept_nonblock(rb_cSocket, fptr, (struct sockaddr *)buf, &amp;len);
    return rb_assoc_new(sock2, rb_str_new(buf, len));
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M007155">
                    
                    <a name="M007155"></a><b>socket.bind(server_sockaddr) => 0
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Binds to the given <tt>struct</tt> sockaddr.
</p>
<h3>Parameter</h3>
<ul>
<li><tt>server_sockaddr</tt> - the <tt>struct</tt> sockaddr contained in a
string

</li>
</ul>
<h3>Example</h3>
<pre>
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.bind( sockaddr )
</pre>
<h3>Unix-based Exceptions</h3>
<p>
On unix-based based systems the following system exceptions may be raised
if the call to <em>bind</em> fails:
</p>
<ul>
<li>Errno::EACCES - the specified <em>sockaddr</em> is protected and the
current user does not have permission to bind to it

</li>
<li>Errno::EADDRINUSE - the specified <em>sockaddr</em> is already in use

</li>
<li>Errno::EADDRNOTAVAIL - the specified <em>sockaddr</em> is not available
from the local machine

</li>
<li>Errno::EAFNOSUPPORT - the specified <em>sockaddr</em> isnot a valid address
for the family of the calling <tt>socket</tt>

</li>
<li>Errno::EBADF - the <em>sockaddr</em> specified is not a valid file
descriptor

</li>
<li>Errno::EFAULT - the <em>sockaddr</em> argument cannot be accessed

</li>
<li>Errno::EINVAL - the <tt>socket</tt> is already bound to an address, and the
protocol does not support binding to the new <em>sockaddr</em> or the
<tt>socket</tt> has been shut down.

</li>
<li>Errno::EINVAL - the address length is not a valid length for the address
family

</li>
<li>Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
PATH_MAX

</li>
<li>Errno::ENOBUFS - no buffer space is available

</li>
<li>Errno::ENOSR - there were insufficient STREAMS resources available to
complete the operation

</li>
<li>Errno::ENOTSOCK - the <tt>socket</tt> does not refer to a socket

</li>
<li>Errno::EOPNOTSUPP - the socket type of the <tt>socket</tt> does not support
binding to an address

</li>
</ul>
<p>
On unix-based based systems if the address family of the calling
<tt>socket</tt> is Socket::AF_UNIX the follow exceptions may be raised if
the call to <em>bind</em> fails:
</p>
<ul>
<li>Errno::EACCES - search permission is denied for a component of the prefix
path or write access to the <tt>socket</tt> is denided

</li>
<li>Errno::EDESTADDRREQ - the <em>sockaddr</em> argument is a null pointer

</li>
<li>Errno::EISDIR - same as Errno::EDESTADDRREQ

</li>
<li>Errno::EIO - an i/o error occurred

</li>
<li>Errno::ELOOP - too many symbolic links were encountered in translating the
pathname in <em>sockaddr</em>

</li>
<li>Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX
characters, or an entired pathname exceeded PATH_MAX characters

</li>
<li>Errno::ENOENT - a component of the pathname does not name an existing file
or the pathname is an empty string

</li>
<li>Errno::ENOTDIR - a component of the path prefix of the pathname in
<em>sockaddr</em> is not a directory

</li>
<li>Errno::EROFS - the name would reside on a read only filesystem

</li>
</ul>
<h3>Windows Exceptions</h3>
<p>
On Windows systems the following system exceptions may be raised if the
call to <em>bind</em> fails:
</p>
<ul>
<li>Errno::ENETDOWN&#8212; the network is down

</li>
<li>Errno::EACCES - the attempt to connect the datagram socket to the broadcast
address failed

</li>
<li>Errno::EADDRINUSE - the socket&#8217;s local address is already in use

</li>
<li>Errno::EADDRNOTAVAIL - the specified address is not a valid address for
this computer

</li>
<li>Errno::EFAULT - the socket&#8217;s internal address or address length
parameter is too small or is not a valid part of the user space addressed

</li>
<li>Errno::EINVAL - the <tt>socket</tt> is already bound to an address

</li>
<li>Errno::ENOBUFS - no buffer space is available

</li>
<li>Errno::ENOTSOCK - the <tt>socket</tt> argument does not refer to a socket

</li>
</ul>
<h3>See</h3>
<ul>
<li>bind manual pages on unix-based systems

</li>
<li>bind function in Microsoft&#8217;s Winsock functions reference

</li>
</ul>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M007155_source')" id="l_M007155_source">show</a>
                        
                    </p>
                    <div id="M007155_source" class="dyn-source">
                        <pre>static VALUE
sock_bind(sock, addr)
    VALUE sock, addr;
{
    rb_io_t *fptr;

    StringValue(addr);
    GetOpenFile(sock, fptr);
    if (bind(fileno(fptr-&gt;f), (struct sockaddr*)RSTRING(addr)-&gt;ptr, RSTRING(addr)-&gt;len) &lt; 0)
        rb_sys_fail(&quot;bind(2)&quot;);

    return INT2FIX(0);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M007153">
                    
                    <a name="M007153"></a><b>socket.connect(server_sockaddr) => 0
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Requests a connection to be made on the given <tt>server_sockaddr</tt>.
Returns 0 if successful, otherwise an exception is raised.
</p>
<h3>Parameter</h3>
<ul>
<li><tt>server_sockaddr</tt> - the <tt>struct</tt> sockaddr contained in a
string

</li>
</ul>
<h3>Example:</h3>
<pre>
     # Pull down Google's web page
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 80, 'www.google.com' )
     socket.connect( sockaddr )
     socket.write( &quot;GET / HTTP/1.0\r\n\r\n&quot; )
     results = socket.read
</pre>
<h3>Unix-based Exceptions</h3>
<p>
On unix-based systems the following system exceptions may be raised if the
call to <em>connect</em> fails:
</p>
<ul>
<li>Errno::EACCES - search permission is denied for a component of the prefix
path or write access to the <tt>socket</tt> is denided

</li>
<li>Errno::EADDRINUSE - the <em>sockaddr</em> is already in use

</li>
<li>Errno::EADDRNOTAVAIL - the specified <em>sockaddr</em> is not available
from the local machine

</li>
<li>Errno::EAFNOSUPPORT - the specified <em>sockaddr</em> is not a valid
address for the address family of the specified <tt>socket</tt>

</li>
<li>Errno::EALREADY - a connection is already in progress for the specified
socket

</li>
<li>Errno::EBADF - the <tt>socket</tt> is not a valid file descriptor

</li>
<li>Errno::ECONNREFUSED - the target <em>sockaddr</em> was not listening for
connections refused the connection request

</li>
<li>Errno::ECONNRESET - the remote host reset the connection request

</li>
<li>Errno::EFAULT - the <em>sockaddr</em> cannot be accessed

</li>
<li>Errno::EHOSTUNREACH - the destination host cannot be reached (probably
because the host is down or a remote router cannot reach it)

</li>
<li>Errno::EINPROGRESS - the O_NONBLOCK is set for the <tt>socket</tt> and the
connection cnanot be immediately established; the connection will be
established asynchronously

</li>
<li>Errno::EINTR - the attempt to establish the connection was interrupted by
delivery of a signal that was caught; the connection will be established
asynchronously

</li>
<li>Errno::EISCONN - the specified <tt>socket</tt> is already connected

</li>
<li>Errno::EINVAL - the address length used for the <em>sockaddr</em> is not a
valid length for the address family or there is an invalid family in
<em>sockaddr</em>

</li>
<li>Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
PATH_MAX

</li>
<li>Errno::ENETDOWN - the local interface used to reach the destination is down

</li>
<li>Errno::ENETUNREACH - no route to the network is present

</li>
<li>Errno::ENOBUFS - no buffer space is available

</li>
<li>Errno::ENOSR - there were insufficient STREAMS resources available to
complete the operation

</li>
<li>Errno::ENOTSOCK - the <tt>socket</tt> argument does not refer to a socket

</li>
<li>Errno::EOPNOTSUPP - the calling <tt>socket</tt> is listening and cannot be
connected

</li>
<li>Errno::EPROTOTYPE - the <em>sockaddr</em> has a different type than the
socket bound to the specified peer address

</li>
<li>Errno::ETIMEDOUT - the attempt to connect time out before a connection was
made.

</li>
</ul>
<p>
On unix-based systems if the address family of the calling <tt>socket</tt>
is AF_UNIX the follow exceptions may be raised if the call to
<em>connect</em> fails:
</p>
<ul>
<li>Errno::EIO - an i/o error occured while reading from or writing to the file
system

</li>
<li>Errno::ELOOP - too many symbolic links were encountered in translating the
pathname in <em>sockaddr</em>

</li>
<li>Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX
characters, or an entired pathname exceeded PATH_MAX characters

</li>
<li>Errno::ENOENT - a component of the pathname does not name an existing file
or the pathname is an empty string

</li>
<li>Errno::ENOTDIR - a component of the path prefix of the pathname in
<em>sockaddr</em> is not a directory

</li>
</ul>
<h3>Windows Exceptions</h3>
<p>
On Windows systems the following system exceptions may be raised if the
call to <em>connect</em> fails:
</p>
<ul>
<li>Errno::ENETDOWN - the network is down

</li>
<li>Errno::EADDRINUSE - the socket&#8217;s local address is already in use

</li>
<li>Errno::EINTR - the socket was cancelled

</li>
<li>Errno::EINPROGRESS - a blocking socket is in progress or the service
provider is still processing a callback function. Or a nonblocking connect
call is in progress on the <tt>socket</tt>.

</li>
<li>Errno::EALREADY - see Errno::EINVAL

</li>
<li>Errno::EADDRNOTAVAIL - the remote address is not a valid address, such as
ADDR_ANY TODO check ADDRANY TO INADDR_ANY

</li>
<li>Errno::EAFNOSUPPORT - addresses in the specified family cannot be used with
with this <tt>socket</tt>

</li>
<li>Errno::ECONNREFUSED - the target <em>sockaddr</em> was not listening for
connections refused the connection request

</li>
<li>Errno::EFAULT - the socket&#8217;s internal address or address length
parameter is too small or is not a valid part of the user space address

</li>
<li>Errno::EINVAL - the <tt>socket</tt> is a listening socket

</li>
<li>Errno::EISCONN - the <tt>socket</tt> is already connected

</li>
<li>Errno::ENETUNREACH - the network cannot be reached from this host at this
time

</li>
<li>Errno::EHOSTUNREACH - no route to the network is present

</li>
<li>Errno::ENOBUFS - no buffer space is available

</li>
<li>Errno::ENOTSOCK - the <tt>socket</tt> argument does not refer to a socket

</li>
<li>Errno::ETIMEDOUT - the attempt to connect time out before a connection was
made.

</li>
<li>Errno::EWOULDBLOCK - the socket is marked as nonblocking and the connection
cannot be completed immediately

</li>
<li>Errno::EACCES - the attempt to connect the datagram socket to the broadcast
address failed

</li>
</ul>
<h3>See</h3>
<ul>
<li>connect manual pages on unix-based systems

</li>
<li>connect function in Microsoft&#8217;s Winsock functions reference

</li>
</ul>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M007153_source')" id="l_M007153_source">show</a>
                        
                    </p>
                    <div id="M007153_source" class="dyn-source">
                        <pre>static VALUE
sock_connect(sock, addr)
    VALUE sock, addr;
{
    rb_io_t *fptr;
    int fd;

    StringValue(addr);
    addr = rb_str_new4(addr);
    GetOpenFile(sock, fptr);
    fd = fileno(fptr-&gt;f);
    if (ruby_connect(fd, (struct sockaddr*)RSTRING(addr)-&gt;ptr, RSTRING(addr)-&gt;len, 0) &lt; 0) {
        rb_sys_fail(&quot;connect(2)&quot;);
    }

    return INT2FIX(0);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M007154">
                    
                    <a name="M007154"></a><b>socket.connect_nonblock(server_sockaddr) => 0
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Requests a connection to be made on the given <tt>server_sockaddr</tt>
after O_NONBLOCK is set for the underlying file descriptor. Returns 0 if
successful, otherwise an exception is raised.
</p>
<h3>Parameter</h3>
<ul>
<li><tt>server_sockaddr</tt> - the <tt>struct</tt> sockaddr contained in a
string

</li>
</ul>
<h3>Example:</h3>
<pre>
     # Pull down Google's web page
     require 'socket'
     include Socket::Constants
     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
     sockaddr = Socket.sockaddr_in(80, 'www.google.com')
     begin
       socket.connect_nonblock(sockaddr)
     rescue Errno::EINPROGRESS
       IO.select(nil, [socket])
       begin
         socket.connect_nonblock(sockaddr)
       rescue Errno::EISCONN
       end
     end
     socket.write(&quot;GET / HTTP/1.0\r\n\r\n&quot;)
     results = socket.read
</pre>
<p>
Refer to <a href="Socket.html#M007153">Socket#connect</a> for the
exceptions that may be thrown if the call to <em><a
href="Socket.html#M007154">connect_nonblock</a></em> fails.
</p>
<p>
<a href="Socket.html#M007154">Socket#connect_nonblock</a> may raise any
error corresponding to connect(2) failure, including Errno::EINPROGRESS.
</p>
<h3>See</h3>
<ul>
<li><a href="Socket.html#M007153">Socket#connect</a>

</li>
</ul>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M007154_source')" id="l_M007154_source">show</a>
                        
                    </p>
                    <div id="M007154_source" class="dyn-source">
                        <pre>static VALUE
sock_connect_nonblock(sock, addr)
    VALUE sock, addr;
{
    rb_io_t *fptr;
    int n;

    StringValue(addr);
    addr = rb_str_new4(addr);
    GetOpenFile(sock, fptr);
    rb_io_set_nonblock(fptr);
    n = connect(fileno(fptr-&gt;f), (struct sockaddr*)RSTRING(addr)-&gt;ptr, RSTRING(addr)-&gt;len);
    if (n &lt; 0) {
        rb_sys_fail(&quot;connect(2)&quot;);
    }

    return INT2FIX(n);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M007156">
                    
                    <a name="M007156"></a><b>socket.listen( int ) => 0
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Listens for connections, using the specified <tt>int</tt> as the backlog. A
call to <em>listen</em> only applies if the <tt>socket</tt> is of type
SOCK_STREAM or SOCK_SEQPACKET.
</p>
<h3>Parameter</h3>
<ul>
<li><tt>backlog</tt> - the maximum length of the queue for pending connections.

</li>
</ul>
<h3>Example 1</h3>
<pre>
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.bind( sockaddr )
     socket.listen( 5 )
</pre>
<h3>Example 2 (listening on an arbitary port, unix-based systems only):</h3>
<pre>
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     socket.listen( 1 )
</pre>
<h3>Unix-based Exceptions</h3>
<p>
On unix based systems the above will work because a new <tt>sockaddr</tt>
struct is created on the address ADDR_ANY, for an arbitrary port number as
handed off by the kernel. It will not work on Windows, because Windows
requires that the <tt>socket</tt> is bound by calling <em>bind</em> before
it can <em>listen</em>.
</p>
<p>
If the <em>backlog</em> amount exceeds the implementation-dependent maximum
queue length, the implementation&#8217;s maximum queue length will be used.
</p>
<p>
On unix-based based systems the following system exceptions may be raised
if the call to <em>listen</em> fails:
</p>
<ul>
<li>Errno::EBADF - the <em>socket</em> argument is not a valid file descriptor

</li>
<li>Errno::EDESTADDRREQ - the <em>socket</em> is not bound to a local address,
and the protocol does not support listening on an unbound socket

</li>
<li>Errno::EINVAL - the <em>socket</em> is already connected

</li>
<li>Errno::ENOTSOCK - the <em>socket</em> argument does not refer to a socket

</li>
<li>Errno::EOPNOTSUPP - the <em>socket</em> protocol does not support listen

</li>
<li>Errno::EACCES - the calling process does not have approriate privileges

</li>
<li>Errno::EINVAL - the <em>socket</em> has been shut down

</li>
<li>Errno::ENOBUFS - insufficient resources are available in the system to
complete the call

</li>
</ul>
<h3>Windows Exceptions</h3>
<p>
On Windows systems the following system exceptions may be raised if the
call to <em>listen</em> fails:
</p>
<ul>
<li>Errno::ENETDOWN - the network is down

</li>
<li>Errno::EADDRINUSE - the socket&#8217;s local address is already in use.
This usually occurs during the execution of <em>bind</em> but could be
delayed if the call to <em>bind</em> was to a partially wildcard address
(involving ADDR_ANY) and if a specific address needs to be commmitted at
the time of the call to <em>listen</em>

</li>
<li>Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the
service provider is still processing a callback function

</li>
<li>Errno::EINVAL - the <tt>socket</tt> has not been bound with a call to
<em>bind</em>.

</li>
<li>Errno::EISCONN - the <tt>socket</tt> is already connected

</li>
<li>Errno::EMFILE - no more socket descriptors are available

</li>
<li>Errno::ENOBUFS - no buffer space is available

</li>
<li>Errno::ENOTSOC - <tt>socket</tt> is not a socket

</li>
<li>Errno::EOPNOTSUPP - the referenced <tt>socket</tt> is not a type that
supports the <em>listen</em> method

</li>
</ul>
<h3>See</h3>
<ul>
<li>listen manual pages on unix-based systems

</li>
<li>listen function in Microsoft&#8217;s Winsock functions reference

</li>
</ul>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M007156_source')" id="l_M007156_source">show</a>
                        
                    </p>
                    <div id="M007156_source" class="dyn-source">
                        <pre>static VALUE
sock_listen(sock, log)
    VALUE sock, log;
{
    rb_io_t *fptr;
    int backlog;

    rb_secure(4);
    backlog = NUM2INT(log);
    GetOpenFile(sock, fptr);
    if (listen(fileno(fptr-&gt;f), backlog) &lt; 0)
        rb_sys_fail(&quot;listen(2)&quot;);

    return INT2FIX(0);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M007160">
                    
                    <a name="M007160"></a><b>socket.recvfrom(maxlen) => [mesg, sender_sockaddr]
socket.recvfrom(maxlen, flags) => [mesg, sender_sockaddr]
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Receives up to <em>maxlen</em> bytes from <tt>socket</tt>. <em>flags</em>
is zero or more of the <tt>MSG_</tt> options. The first element of the
results, <em>mesg</em>, is the data received. The second element,
<em>sender_sockaddr</em>, contains protocol-specific information on the
sender.
</p>
<h3>Parameters</h3>
<ul>
<li><tt>maxlen</tt> - the number of bytes to receive from the socket

</li>
<li><tt>flags</tt> - zero or more of the <tt>MSG_</tt> options

</li>
</ul>
<h3>Example</h3>
<pre>
     # In one file, start this first
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.bind( sockaddr )
     socket.listen( 5 )
     client, client_sockaddr = socket.accept
     data = client.recvfrom( 20 )[0].chomp
     puts &quot;I only received 20 bytes '#{data}'&quot;
     sleep 1
     socket.close

     # In another file, start this second
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.connect( sockaddr )
     socket.puts &quot;Watch this get cut short!&quot;
     socket.close
</pre>
<h3>Unix-based Exceptions</h3>
<p>
On unix-based based systems the following system exceptions may be raised
if the call to <em>recvfrom</em> fails:
</p>
<ul>
<li>Errno::EAGAIN - the <tt>socket</tt> file descriptor is marked as O_NONBLOCK
and no data is waiting to be received; or MSG_OOB is set and no out-of-band
data is available and either the <tt>socket</tt> file descriptor is marked
as O_NONBLOCK or the <tt>socket</tt> does not support blocking to wait for
out-of-band-data

</li>
<li>Errno::EWOULDBLOCK - see Errno::EAGAIN

</li>
<li>Errno::EBADF - the <tt>socket</tt> is not a valid file descriptor

</li>
<li>Errno::ECONNRESET - a connection was forcibly closed by a peer

</li>
<li>Errno::EFAULT - the socket&#8217;s internal buffer, address or address
length cannot be accessed or written

</li>
<li>Errno::EINTR - a signal interupted <em>recvfrom</em> before any data was
available

</li>
<li>Errno::EINVAL - the MSG_OOB flag is set and no out-of-band data is
available

</li>
<li>Errno::EIO - an i/o error occurred while reading from or writing to the
filesystem

</li>
<li>Errno::ENOBUFS - insufficient resources were available in the system to
perform the operation

</li>
<li>Errno::ENOMEM - insufficient memory was available to fulfill the request

</li>
<li>Errno::ENOSR - there were insufficient STREAMS resources available to
complete the operation

</li>
<li>Errno::ENOTCONN - a receive is attempted on a connection-mode socket that
is not connected

</li>
<li>Errno::ENOTSOCK - the <tt>socket</tt> does not refer to a socket

</li>
<li>Errno::EOPNOTSUPP - the specified flags are not supported for this socket
type

</li>
<li>Errno::ETIMEDOUT - the connection timed out during connection establishment
or due to a transmission timeout on an active connection

</li>
</ul>
<h3>Windows Exceptions</h3>
<p>
On Windows systems the following system exceptions may be raised if the
call to <em>recvfrom</em> fails:
</p>
<ul>
<li>Errno::ENETDOWN - the network is down

</li>
<li>Errno::EFAULT - the internal buffer and from parameters on <tt>socket</tt>
are not part of the user address space, or the internal fromlen parameter
is too small to accomodate the peer address

</li>
<li>Errno::EINTR - the (blocking) call was cancelled by an internal call to the
WinSock function WSACancelBlockingCall

</li>
<li>Errno::EINPROGRESS - a blocking Windows Sockets 1.1 call is in progress or
the service provider is still processing a callback function

</li>
<li>Errno::EINVAL - <tt>socket</tt> has not been bound with a call to
<em>bind</em>, or an unknown flag was specified, or MSG_OOB was specified
for a socket with SO_OOBINLINE enabled, or (for byte stream-style sockets
only) the internal len parameter on <tt>socket</tt> was zero or negative

</li>
<li>Errno::EISCONN - <tt>socket</tt> is already connected. The call to
<em>recvfrom</em> is not permitted with a connected socket on a socket that
is connetion oriented or connectionless.

</li>
<li>Errno::ENETRESET - the connection has been broken due to the keep-alive
activity detecting a failure while the operation was in progress.

</li>
<li>Errno::EOPNOTSUPP - MSG_OOB was specified, but <tt>socket</tt> is not
stream-style such as type SOCK_STREAM. OOB data is not supported in the
communication domain associated with <tt>socket</tt>, or <tt>socket</tt> is
unidirectional and supports only send operations

</li>
<li>Errno::ESHUTDOWN - <tt>socket</tt> has been shutdown. It is not possible to
call <em>recvfrom</em> on a socket after <em>shutdown</em> has been
invoked.

</li>
<li>Errno::EWOULDBLOCK - <tt>socket</tt> is marked as nonblocking and a call to
<em>recvfrom</em> would block.

</li>
<li>Errno::EMSGSIZE - the message was too large to fit into the specified
buffer and was truncated.

</li>
<li>Errno::ETIMEDOUT - the connection has been dropped, because of a network
failure or because the system on the other end went down without notice

</li>
<li>Errno::ECONNRESET - the virtual circuit was reset by the remote side
executing a hard or abortive close. The application should close the
socket; it is no longer usable. On a UDP-datagram socket this error
indicates a previous send operation resulted in an ICMP Port Unreachable
message.

</li>
</ul>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M007160_source')" id="l_M007160_source">show</a>
                        
                    </p>
                    <div id="M007160_source" class="dyn-source">
                        <pre>static VALUE
sock_recvfrom(argc, argv, sock)
    int argc;
    VALUE *argv;
    VALUE sock;
{
    return s_recvfrom(sock, argc, argv, RECV_SOCKET);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M007161">
                    
                    <a name="M007161"></a><b>socket.recvfrom_nonblock(maxlen) => [mesg, sender_sockaddr]
socket.recvfrom_nonblock(maxlen, flags) => [mesg, sender_sockaddr]
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Receives up to <em>maxlen</em> bytes from <tt>socket</tt> using recvfrom(2)
after O_NONBLOCK is set for the underlying file descriptor. <em>flags</em>
is zero or more of the <tt>MSG_</tt> options. The first element of the
results, <em>mesg</em>, is the data received. The second element,
<em>sender_sockaddr</em>, contains protocol-specific information on the
sender.
</p>
<p>
When recvfrom(2) returns 0, <a
href="Socket.html#M007161">Socket#recvfrom_nonblock</a> returns an empty
string as data. The meaning depends on the socket: EOF on TCP, empty packet
on UDP, etc.
</p>
<h3>Parameters</h3>
<ul>
<li><tt>maxlen</tt> - the number of bytes to receive from the socket

</li>
<li><tt>flags</tt> - zero or more of the <tt>MSG_</tt> options

</li>
</ul>
<h3>Example</h3>
<pre>
     # In one file, start this first
     require 'socket'
     include Socket::Constants
     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
     sockaddr = Socket.sockaddr_in(2200, 'localhost')
     socket.bind(sockaddr)
     socket.listen(5)
     client, client_sockaddr = socket.accept
     begin
       pair = client.recvfrom_nonblock(20)
     rescue Errno::EAGAIN, Errno::EWOULDBLOCK
       IO.select([client])
       retry
     end
     data = pair[0].chomp
     puts &quot;I only received 20 bytes '#{data}'&quot;
     sleep 1
     socket.close

     # In another file, start this second
     require 'socket'
     include Socket::Constants
     socket = Socket.new(AF_INET, SOCK_STREAM, 0)
     sockaddr = Socket.sockaddr_in(2200, 'localhost')
     socket.connect(sockaddr)
     socket.puts &quot;Watch this get cut short!&quot;
     socket.close
</pre>
<p>
Refer to <a href="Socket.html#M007160">Socket#recvfrom</a> for the
exceptions that may be thrown if the call to <em><a
href="Socket.html#M007161">recvfrom_nonblock</a></em> fails.
</p>
<p>
<a href="Socket.html#M007161">Socket#recvfrom_nonblock</a> may raise any
error corresponding to recvfrom(2) failure, including Errno::EAGAIN.
</p>
<h3>See</h3>
<ul>
<li><a href="Socket.html#M007160">Socket#recvfrom</a>

</li>
</ul>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M007161_source')" id="l_M007161_source">show</a>
                        
                    </p>
                    <div id="M007161_source" class="dyn-source">
                        <pre>static VALUE
sock_recvfrom_nonblock(int argc, VALUE *argv, VALUE sock)
{
    return s_recvfrom_nonblock(sock, argc, argv, RECV_SOCKET);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M007159">
                    
                    <a name="M007159"></a><b>socket.sysaccept => [client_socket_fd, client_sockaddr]
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Accepts an incoming connection returnings an array containg the (integer)
file descriptor for the incoming connection, <em>client_socket_fd</em>, and
a string that contains the <tt>struct</tt> sockaddr information about the
caller, <em>client_sockaddr</em>.
</p>
<h3>Example</h3>
<pre>
     # In one script, start this first
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.bind( sockaddr )
     socket.listen( 5 )
     client_fd, client_sockaddr = socket.sysaccept
     client_socket = Socket.for_fd( client_fd )
     puts &quot;The client said, '#{client_socket.readline.chomp}'&quot;
     client_socket.puts &quot;Hello from script one!&quot;
     socket.close

     # In another script, start this second
     require 'socket'
     include Socket::Constants
     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
     sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
     socket.connect( sockaddr )
     socket.puts &quot;Hello from script 2.&quot;
     puts &quot;The server said, '#{socket.readline.chomp}'&quot;
     socket.close
</pre>
<p>
Refer to <a href="Socket.html#M007157">Socket#accept</a> for the exceptions
that may be thrown if the call to <em>sysaccept</em> fails.
</p>
<h3>See</h3>
<ul>
<li><a href="Socket.html#M007157">Socket#accept</a>

</li>
</ul>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M007159_source')" id="l_M007159_source">show</a>
                        
                    </p>
                    <div id="M007159_source" class="dyn-source">
                        <pre>static VALUE
sock_sysaccept(sock)
    VALUE sock;
{
    rb_io_t *fptr;
    VALUE sock2;
    char buf[1024];
    socklen_t len = sizeof buf;

    GetOpenFile(sock, fptr);
    sock2 = s_accept(0,fileno(fptr-&gt;f),(struct sockaddr*)buf,&amp;len);

    return rb_assoc_new(sock2, rb_str_new(buf, len));
}</pre>
                    </div>
                </div>
                
            </div>
            
</div>
    </div>
  </body>
</html>    