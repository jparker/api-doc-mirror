<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>Encoding::Converter</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" href="../../css/reset.css" type="text/css" media="screen" />
    <link rel="stylesheet" href="../../css/main.css" type="text/css" media="screen" />
    <script src="../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
    <script src="../../js/main.js" type="text/javascript" charset="utf-8"></script>
</head>

<body>     
    <div class="banner">
        <h1>
            <span class="type">Class</span> 
            Encoding::Converter 
            
                <span class="parent">&lt; 
                    
                    <a href="../Data.html">Data</a>
                    
                </span>
            
        </h1>
        <ul class="files">
            
            <li><a href="../../files/transcode_c.html">transcode.c</a></li>
            
        </ul>
    </div>
    <div id="bodyContent">
        <div id="content">
    
    <div class="description">
        <p>
Document-class: <a
href="ConverterNotFoundError.html">Encoding::ConverterNotFoundError</a>
</p>
<p>
Raised by transcoding methods when a named encoding does not correspond
with a known converter.
</p>

    </div>
    

    

    
    

    
    
    <div class="sectiontitle">Methods</div>
    <dl class="methods">
    
        <dt>A</dt>
        <dd>
            <ul>
                
                <li><a href="#M000928">asciicompat_encoding</a></li>
                
            </ul>
        </dd>
    
        <dt>C</dt>
        <dd>
            <ul>
                
                <li><a href="#M000936">convert</a>,</li>
                
                <li><a href="#M000932">convpath</a></li>
                
            </ul>
        </dd>
    
        <dt>D</dt>
        <dd>
            <ul>
                
                <li><a href="#M000934">destination_encoding</a></li>
                
            </ul>
        </dd>
    
        <dt>F</dt>
        <dd>
            <ul>
                
                <li><a href="#M000937">finish</a></li>
                
            </ul>
        </dd>
    
        <dt>I</dt>
        <dd>
            <ul>
                
                <li><a href="#M000939">insert_output</a>,</li>
                
                <li><a href="#M000931">inspect</a></li>
                
            </ul>
        </dd>
    
        <dt>L</dt>
        <dd>
            <ul>
                
                <li><a href="#M000941">last_error</a></li>
                
            </ul>
        </dd>
    
        <dt>N</dt>
        <dd>
            <ul>
                
                <li><a href="#M000930">new</a></li>
                
            </ul>
        </dd>
    
        <dt>P</dt>
        <dd>
            <ul>
                
                <li><a href="#M000935">primitive_convert</a>,</li>
                
                <li><a href="#M000938">primitive_errinfo</a>,</li>
                
                <li><a href="#M000940">putback</a></li>
                
            </ul>
        </dd>
    
        <dt>R</dt>
        <dd>
            <ul>
                
                <li><a href="#M000942">replacement</a>,</li>
                
                <li><a href="#M000943">replacement=</a></li>
                
            </ul>
        </dd>
    
        <dt>S</dt>
        <dd>
            <ul>
                
                <li><a href="#M000929">search_convpath</a>,</li>
                
                <li><a href="#M000933">source_encoding</a></li>
                
            </ul>
        </dd>
    
    </dl>
    

    

    

    

    
    <div class="sectiontitle">Constants</div>
    <table border='0' cellpadding='5'>
        
        <tr valign='top'>
            <td class="attr-name">INVALID_MASK</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(ECONV_INVALID_MASK)</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">INVALID_REPLACE</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(ECONV_INVALID_REPLACE)</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">UNDEF_MASK</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(ECONV_UNDEF_MASK)</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">UNDEF_REPLACE</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(ECONV_UNDEF_REPLACE)</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">UNDEF_HEX_CHARREF</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(ECONV_UNDEF_HEX_CHARREF)</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">PARTIAL_INPUT</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(ECONV_PARTIAL_INPUT)</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">AFTER_OUTPUT</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(ECONV_AFTER_OUTPUT)</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">UNIVERSAL_NEWLINE_DECORATOR</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(ECONV_UNIVERSAL_NEWLINE_DECORATOR)</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">CRLF_NEWLINE_DECORATOR</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(ECONV_CRLF_NEWLINE_DECORATOR)</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">CR_NEWLINE_DECORATOR</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(ECONV_CR_NEWLINE_DECORATOR)</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">XML_TEXT_DECORATOR</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(ECONV_XML_TEXT_DECORATOR)</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">XML_ATTR_CONTENT_DECORATOR</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(ECONV_XML_ATTR_CONTENT_DECORATOR)</td>
        </tr>
        
        
        <tr valign='top'>
            <td class="attr-name">XML_ATTR_QUOTE_DECORATOR</td>
            <td>=</td>
            <td class="attr-value">INT2FIX(ECONV_XML_ATTR_QUOTE_DECORATOR)</td>
        </tr>
        
        
    </table>
    

    

    
            <div class="sectiontitle">Class Public methods</div>
            
            <div class="method">
                <div class="title" id="M000928">
                    
                    <a name="M000928"></a><b>Encoding::Converter.asciicompat_encoding(string) &rarr; encoding or nil
Encoding::Converter.asciicompat_encoding(encoding) &rarr; encoding or nil
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns the corresponding ASCII compatible encoding.
</p>
<p>
Returns nil if the argument is an ASCII compatible encoding.
</p>
<p>
&#8220;corresponding ASCII compatible encoding&#8221; is a ASCII compatible
encoding which can represents exactly the same characters as the given
ASCII incompatible encoding. So, no conversion undefined error occurs when
converting between the two encodings.
</p>
<pre>
  Encoding::Converter.asciicompat_encoding(&quot;ISO-2022-JP&quot;) #=&gt; #&lt;Encoding:stateless-ISO-2022-JP&gt;
  Encoding::Converter.asciicompat_encoding(&quot;UTF-16BE&quot;) #=&gt; #&lt;Encoding:UTF-8&gt;
  Encoding::Converter.asciicompat_encoding(&quot;UTF-8&quot;) #=&gt; nil
</pre>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000928_source')" id="l_M000928_source">show</a>
                        
                    </p>
                    <div id="M000928_source" class="dyn-source">
                        <pre>static VALUE
econv_s_asciicompat_encoding(VALUE klass, VALUE arg)
{
    const char *arg_name, *result_name;
    rb_encoding *arg_enc, *result_enc;

    enc_arg(&amp;arg, &amp;arg_name, &amp;arg_enc);

    result_name = rb_econv_asciicompat_encoding(arg_name);

    if (result_name == NULL)
        return Qnil;

    result_enc = make_encoding(result_name);

    return rb_enc_from_encoding(result_enc);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000930">
                    
                    <a name="M000930"></a><b>Encoding::Converter.new(source_encoding, destination_encoding)
Encoding::Converter.new(source_encoding, destination_encoding, opt)
Encoding::Converter.new(convpath)
</b>
                    
                </div>
                
                <div class="description">
                  <p>
possible options elements:
</p>
<pre>
  hash form:
    :invalid =&gt; nil            # raise error on invalid byte sequence (default)
    :invalid =&gt; :replace       # replace invalid byte sequence
    :undef =&gt; nil              # raise error on undefined conversion (default)
    :undef =&gt; :replace         # replace undefined conversion
    :replace =&gt; string         # replacement string (&quot;?&quot; or &quot;\uFFFD&quot; if not specified)
    :universal_newline =&gt; true # decorator for converting CRLF and CR to LF
    :crlf_newline =&gt; true      # decorator for converting LF to CRLF
    :cr_newline =&gt; true        # decorator for converting LF to CR
    :xml =&gt; :text              # escape as XML CharData.
    :xml =&gt; :attr              # escape as XML AttValue
  integer form:
    Encoding::Converter::INVALID_REPLACE
    Encoding::Converter::UNDEF_REPLACE
    Encoding::Converter::UNDEF_HEX_CHARREF
    Encoding::Converter::UNIVERSAL_NEWLINE_DECORATOR
    Encoding::Converter::CRLF_NEWLINE_DECORATOR
    Encoding::Converter::CR_NEWLINE_DECORATOR
    Encoding::Converter::XML_TEXT_DECORATOR
    Encoding::Converter::XML_ATTR_CONTENT_DECORATOR
    Encoding::Converter::XML_ATTR_QUOTE_DECORATOR
</pre>
<p>
<a href="Converter.html#M000930">Encoding::Converter.new</a> creates an
instance of <a href="Converter.html">Encoding::Converter</a>.
</p>
<p>
Source_encoding and <a
href="Converter.html#M000934">destination_encoding</a> should be a string
or <a href="../Encoding.html">Encoding</a> object.
</p>
<p>
opt should be nil, a hash or an integer.
</p>
<p>
convpath should be an array. convpath may contain
</p>
<ul>
<li>two-element arrays which contain encodings or encoding names, or

</li>
<li>strings representing decorator names.

</li>
</ul>
<p>
<a href="Converter.html#M000930">Encoding::Converter.new</a> optionally
takes an option. The option should be a hash or an integer. The option hash
can contain :invalid => nil, etc. The option integer should be logical-or
of constants such as Encoding::Converter::INVALID_REPLACE, etc.
</p>
<dl>
<dt>:invalid => nil</dt><dd>Raise error on invalid byte sequence. This is a default behavior.

</dd>
<dt>:invalid => :replace</dt><dd>Replace invalid byte sequence by replacement string.

</dd>
<dt>:undef => nil</dt><dd>Raise an error if a character in <a
href="Converter.html#M000933">source_encoding</a> is not defined in
destination_encoding. This is a default behavior.

</dd>
<dt>:undef => :replace</dt><dd>Replace undefined character in <a
href="Converter.html#M000934">destination_encoding</a> with replacement
string.

</dd>
<dt>:replace => string</dt><dd>Specify the replacement string. If not specified, &#8220;uFFFD&#8221; is
used for Unicode encodings and &#8220;?&#8221; for others.

</dd>
<dt>:universal_newline => true</dt><dd>Convert CRLF and CR to LF.

</dd>
<dt>:crlf_newline => true</dt><dd>Convert LF to CRLF.

</dd>
<dt>:cr_newline => true</dt><dd>Convert LF to CR.

</dd>
<dt>:xml => :text</dt><dd>Escape as XML CharData. This form can be used as a HTML 4.0 PCDATA.

<ul>
<li>&#8217;&amp;&#8217; -> &#8217;&amp;amp;&#8217;

</li>
<li>&#8217;<&#8217; -> &#8217;&amp;lt;&#8217;

</li>
<li>&#8217;>&#8217; -> &#8217;&amp;gt;&#8217;

</li>
<li>undefined characters in <a
href="Converter.html#M000934">destination_encoding</a> -> hexadecimal
CharRef such as &amp;xHH;

</li>
</ul>
</dd>
<dt>:xml => :attr</dt><dd>Escape as XML AttValue. The converted result is quoted as
&#8220;&#8230;&#8221;. This form can be used as a HTML 4.0 attribute value.

<ul>
<li>&#8217;&amp;&#8217; -> &#8217;&amp;amp;&#8217;

</li>
<li>&#8217;<&#8217; -> &#8217;&amp;lt;&#8217;

</li>
<li>&#8217;>&#8217; -> &#8217;&amp;gt;&#8217;

</li>
<li>&#8217;&#8221;&#8217; -> &#8217;&amp;quot;&#8217;

</li>
<li>undefined characters in <a
href="Converter.html#M000934">destination_encoding</a> -> hexadecimal
CharRef such as &amp;xHH;

</li>
</ul>
</dd>
</dl>
<p>
Examples:
</p>
<pre>
  # UTF-16BE to UTF-8
  ec = Encoding::Converter.new(&quot;UTF-16BE&quot;, &quot;UTF-8&quot;)

  # Usually, decorators such as newline conversion are inserted last.
  ec = Encoding::Converter.new(&quot;UTF-16BE&quot;, &quot;UTF-8&quot;, :universal_newline =&gt; true)
  p ec.convpath #=&gt; [[#&lt;Encoding:UTF-16BE&gt;, #&lt;Encoding:UTF-8&gt;],
                #    &quot;universal_newline&quot;]

  # But, if the last encoding is ASCII incompatible,
  # decorators are inserted before the last conversion.
  ec = Encoding::Converter.new(&quot;UTF-8&quot;, &quot;UTF-16BE&quot;, :crlf_newline =&gt; true)
  p ec.convpath #=&gt; [&quot;crlf_newline&quot;,
                #    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:UTF-16BE&gt;]]

  # Conversion path can be specified directly.
  ec = Encoding::Converter.new([&quot;universal_newline&quot;, [&quot;EUC-JP&quot;, &quot;UTF-8&quot;], [&quot;UTF-8&quot;, &quot;UTF-16BE&quot;]])
  p ec.convpath #=&gt; [&quot;universal_newline&quot;,
                #    [#&lt;Encoding:EUC-JP&gt;, #&lt;Encoding:UTF-8&gt;],
                #    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:UTF-16BE&gt;]]
</pre>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000930_source')" id="l_M000930_source">show</a>
                        
                    </p>
                    <div id="M000930_source" class="dyn-source">
                        <pre>static VALUE
econv_init(int argc, VALUE *argv, VALUE self)
{
    VALUE ecopts;
    volatile VALUE snamev, dnamev;
    const char *sname, *dname;
    rb_encoding *senc, *denc;
    rb_econv_t *ec;
    int ecflags;
    VALUE convpath;

    if (rb_check_typeddata(self, &amp;econv_data_type)) {
        rb_raise(rb_eTypeError, &quot;already initialized&quot;);
    }

    if (argc == 1 &amp;&amp; !NIL_P(convpath = rb_check_array_type(argv[0]))) {
        ec = rb_econv_init_by_convpath(self, convpath, &amp;sname, &amp;dname, &amp;senc, &amp;denc);
        ecflags = 0;
        ecopts = Qnil;
    }
    else {
        econv_args(argc, argv, &amp;snamev, &amp;dnamev, &amp;sname, &amp;dname, &amp;senc, &amp;denc, &amp;ecflags, &amp;ecopts);
        ec = rb_econv_open_opts(sname, dname, ecflags, ecopts);
    }

    if (!ec) {
        rb_exc_raise(rb_econv_open_exc(sname, dname, ecflags));
    }

    if (!DECORATOR_P(sname, dname)) {
        if (!senc)
            senc = make_dummy_encoding(sname);
        if (!denc)
            denc = make_dummy_encoding(dname);
    }

    ec-&gt;source_encoding = senc;
    ec-&gt;destination_encoding = denc;

    DATA_PTR(self) = ec;

    return self;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000929">
                    
                    <a name="M000929"></a><b>Encoding::Converter.search_convpath(source_encoding, destination_encoding)         &rarr; ary
Encoding::Converter.search_convpath(source_encoding, destination_encoding, opt)    &rarr; ary
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns a conversion path.
</p>
<pre>
 p Encoding::Converter.search_convpath(&quot;ISO-8859-1&quot;, &quot;EUC-JP&quot;)
 #=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],
 #    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:EUC-JP&gt;]]

 p Encoding::Converter.search_convpath(&quot;ISO-8859-1&quot;, &quot;EUC-JP&quot;, universal_newline: true)
 #=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],
 #    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:EUC-JP&gt;],
 #    &quot;universal_newline&quot;]

 p Encoding::Converter.search_convpath(&quot;ISO-8859-1&quot;, &quot;UTF-32BE&quot;, universal_newline: true)
 #=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],
 #    &quot;universal_newline&quot;,
 #    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:UTF-32BE&gt;]]
</pre>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000929_source')" id="l_M000929_source">show</a>
                        
                    </p>
                    <div id="M000929_source" class="dyn-source">
                        <pre>static VALUE
econv_s_search_convpath(int argc, VALUE *argv, VALUE klass)
{
    volatile VALUE snamev, dnamev;
    const char *sname, *dname;
    rb_encoding *senc, *denc;
    int ecflags;
    VALUE ecopts;
    VALUE convpath;

    econv_args(argc, argv, &amp;snamev, &amp;dnamev, &amp;sname, &amp;dname, &amp;senc, &amp;denc, &amp;ecflags, &amp;ecopts);

    convpath = Qnil;
    transcode_search_path(sname, dname, search_convpath_i, &amp;convpath);

    if (NIL_P(convpath))
        rb_exc_raise(rb_econv_open_exc(sname, dname, ecflags));

    if (decorate_convpath(convpath, ecflags) == -1)
        rb_exc_raise(rb_econv_open_exc(sname, dname, ecflags));

    return convpath;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="sectiontitle">Instance Public methods</div>
            
            <div class="method">
                <div class="title" id="M000936">
                    
                    <a name="M000936"></a><b>ec.convert(source_string) &rarr; destination_string
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Convert source_string and return destination_string.
</p>
<p>
source_string is assumed as a part of source. i.e. :partial_input=>true is
specified internally. finish method should be used last.
</p>
<pre>
  ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;euc-jp&quot;)
  puts ec.convert(&quot;\u3042&quot;).dump     #=&gt; &quot;\xA4\xA2&quot;
  puts ec.finish.dump                #=&gt; &quot;&quot;

  ec = Encoding::Converter.new(&quot;euc-jp&quot;, &quot;utf-8&quot;)
  puts ec.convert(&quot;\xA4&quot;).dump       #=&gt; &quot;&quot;
  puts ec.convert(&quot;\xA2&quot;).dump       #=&gt; &quot;\xE3\x81\x82&quot;
  puts ec.finish.dump                #=&gt; &quot;&quot;

  ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;iso-2022-jp&quot;)
  puts ec.convert(&quot;\xE3&quot;).dump       #=&gt; &quot;&quot;.force_encoding(&quot;ISO-2022-JP&quot;)
  puts ec.convert(&quot;\x81&quot;).dump       #=&gt; &quot;&quot;.force_encoding(&quot;ISO-2022-JP&quot;)
  puts ec.convert(&quot;\x82&quot;).dump       #=&gt; &quot;\e$B$\&quot;&quot;.force_encoding(&quot;ISO-2022-JP&quot;)
  puts ec.finish.dump                #=&gt; &quot;\e(B&quot;.force_encoding(&quot;ISO-2022-JP&quot;)
</pre>
<p>
If a conversion error occur, <a
href="UndefinedConversionError.html">Encoding::UndefinedConversionError</a>
or <a
href="InvalidByteSequenceError.html">Encoding::InvalidByteSequenceError</a>
is raised. <a href="Converter.html#M000936">Encoding::Converter#convert</a>
doesn&#8217;t supply methods to recover or restart from these exceptions.
When you want to handle these conversion errors, use <a
href="Converter.html#M000935">Encoding::Converter#primitive_convert</a>.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000936_source')" id="l_M000936_source">show</a>
                        
                    </p>
                    <div id="M000936_source" class="dyn-source">
                        <pre>static VALUE
econv_convert(VALUE self, VALUE source_string)
{
    VALUE ret, dst;
    VALUE av[5];
    int ac;
    rb_econv_t *ec = check_econv(self);

    StringValue(source_string);

    dst = rb_str_new(NULL, 0);

    av[0] = rb_str_dup(source_string);
    av[1] = dst;
    av[2] = Qnil;
    av[3] = Qnil;
    av[4] = INT2NUM(ECONV_PARTIAL_INPUT);
    ac = 5;

    ret = econv_primitive_convert(ac, av, self);

    if (ret == sym_invalid_byte_sequence ||
        ret == sym_undefined_conversion ||
        ret == sym_incomplete_input) {
        VALUE exc = make_econv_exception(ec);
        rb_exc_raise(exc);
    }

    if (ret == sym_finished) {
        rb_raise(rb_eArgError, &quot;converter already finished&quot;);
    }

    if (ret != sym_source_buffer_empty) {
        rb_bug(&quot;unexpected result of econv_primitive_convert&quot;);
    }

    return dst;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000932">
                    
                    <a name="M000932"></a><b>ec.convpath        &rarr; ary
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns the conversion path of ec.
</p>
<p>
The result is an array of conversions.
</p>
<pre>
  ec = Encoding::Converter.new(&quot;ISO-8859-1&quot;, &quot;EUC-JP&quot;, crlf_newline: true)
  p ec.convpath
  #=&gt; [[#&lt;Encoding:ISO-8859-1&gt;, #&lt;Encoding:UTF-8&gt;],
  #    [#&lt;Encoding:UTF-8&gt;, #&lt;Encoding:EUC-JP&gt;],
  #    &quot;crlf_newline&quot;]
</pre>
<p>
Each element of the array is a pair of encodings or a string. <a
href="../A.html">A</a> pair means an encoding conversion. <a
href="../A.html">A</a> string means a decorator.
</p>
<p>
In the above example, [#<Encoding:ISO-8859-1>, #<Encoding:UTF-8>] means a
converter from ISO-8859-1 to UTF-8. &#8220;crlf_newline&#8220; means
newline converter from LF to CRLF.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000932_source')" id="l_M000932_source">show</a>
                        
                    </p>
                    <div id="M000932_source" class="dyn-source">
                        <pre>static VALUE
econv_convpath(VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    VALUE result;
    int i;

    result = rb_ary_new();
    for (i = 0; i &lt; ec-&gt;num_trans; i++) {
        const rb_transcoder *tr = ec-&gt;elems[i].tc-&gt;transcoder;
        VALUE v;
        if (DECORATOR_P(tr-&gt;src_encoding, tr-&gt;dst_encoding))
            v = rb_str_new_cstr(tr-&gt;dst_encoding);
        else
            v = rb_assoc_new(make_encobj(tr-&gt;src_encoding), make_encobj(tr-&gt;dst_encoding));
        rb_ary_push(result, v);
    }
    return result;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000934">
                    
                    <a name="M000934"></a><b>ec.destination_encoding &rarr; encoding
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns the destination encoding as an <a
href="../Encoding.html">Encoding</a> object.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000934_source')" id="l_M000934_source">show</a>
                        
                    </p>
                    <div id="M000934_source" class="dyn-source">
                        <pre>static VALUE
econv_destination_encoding(VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    if (!ec-&gt;destination_encoding)
        return Qnil;
    return rb_enc_from_encoding(ec-&gt;destination_encoding);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000937">
                    
                    <a name="M000937"></a><b>ec.finish &rarr; string
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Finishes the converter. It returns the last part of the converted string.
</p>
<pre>
  ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;iso-2022-jp&quot;)
  p ec.convert(&quot;\u3042&quot;)     #=&gt; &quot;\e$B$\&quot;&quot;
  p ec.finish                #=&gt; &quot;\e(B&quot;
</pre>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000937_source')" id="l_M000937_source">show</a>
                        
                    </p>
                    <div id="M000937_source" class="dyn-source">
                        <pre>static VALUE
econv_finish(VALUE self)
{
    VALUE ret, dst;
    VALUE av[5];
    int ac;
    rb_econv_t *ec = check_econv(self);

    dst = rb_str_new(NULL, 0);

    av[0] = Qnil;
    av[1] = dst;
    av[2] = Qnil;
    av[3] = Qnil;
    av[4] = INT2NUM(0);
    ac = 5;

    ret = econv_primitive_convert(ac, av, self);

    if (ret == sym_invalid_byte_sequence ||
        ret == sym_undefined_conversion ||
        ret == sym_incomplete_input) {
        VALUE exc = make_econv_exception(ec);
        rb_exc_raise(exc);
    }

    if (ret != sym_finished) {
        rb_bug(&quot;unexpected result of econv_primitive_convert&quot;);
    }

    return dst;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000939">
                    
                    <a name="M000939"></a><b>ec.insert_output(string) &rarr; nil
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Inserts string into the encoding converter. The string will be converted to
the destination encoding and output on later conversions.
</p>
<p>
If the destination encoding is stateful, string is converted according to
the state and the state is updated.
</p>
<p>
This method should be used only when a conversion error occurs.
</p>
<pre>
 ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;iso-8859-1&quot;)
 src = &quot;HIRAGANA LETTER A is \u{3042}.&quot;
 dst = &quot;&quot;
 p ec.primitive_convert(src, dst)    #=&gt; :undefined_conversion
 puts &quot;[#{dst.dump}, #{src.dump}]&quot;   #=&gt; [&quot;HIRAGANA LETTER A is &quot;, &quot;.&quot;]
 ec.insert_output(&quot;&lt;err&gt;&quot;)
 p ec.primitive_convert(src, dst)    #=&gt; :finished
 puts &quot;[#{dst.dump}, #{src.dump}]&quot;   #=&gt; [&quot;HIRAGANA LETTER A is &lt;err&gt;.&quot;, &quot;&quot;]

 ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;iso-2022-jp&quot;)
 src = &quot;\u{306F 3041 3068 2661 3002}&quot; # U+2661 is not representable in iso-2022-jp
 dst = &quot;&quot;
 p ec.primitive_convert(src, dst)    #=&gt; :undefined_conversion
 puts &quot;[#{dst.dump}, #{src.dump}]&quot;   #=&gt; [&quot;\e$B$O$!$H&quot;.force_encoding(&quot;ISO-2022-JP&quot;), &quot;\xE3\x80\x82&quot;]
 ec.insert_output &quot;?&quot;                # state change required to output &quot;?&quot;.
 p ec.primitive_convert(src, dst)    #=&gt; :finished
 puts &quot;[#{dst.dump}, #{src.dump}]&quot;   #=&gt; [&quot;\e$B$O$!$H\e(B?\e$B!#\e(B&quot;.force_encoding(&quot;ISO-2022-JP&quot;), &quot;&quot;]
</pre>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000939_source')" id="l_M000939_source">show</a>
                        
                    </p>
                    <div id="M000939_source" class="dyn-source">
                        <pre>static VALUE
econv_insert_output(VALUE self, VALUE string)
{
    const char *insert_enc;

    int ret;

    rb_econv_t *ec = check_econv(self);

    StringValue(string);
    insert_enc = rb_econv_encoding_to_insert_output(ec);
    string = rb_str_encode(string, rb_enc_from_encoding(rb_enc_find(insert_enc)), 0, Qnil);

    ret = rb_econv_insert_output(ec, (const unsigned char *)RSTRING_PTR(string), RSTRING_LEN(string), insert_enc);
    if (ret == -1) {
        rb_raise(rb_eArgError, &quot;too big string&quot;);
    }

    return Qnil;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000931">
                    
                    <a name="M000931"></a><b>ec.inspect         &rarr; string
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns a printable version of <em>ec</em>
</p>
<pre>
  ec = Encoding::Converter.new(&quot;iso-8859-1&quot;, &quot;utf-8&quot;)
  puts ec.inspect    #=&gt; #&lt;Encoding::Converter: ISO-8859-1 to UTF-8&gt;
</pre>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000931_source')" id="l_M000931_source">show</a>
                        
                    </p>
                    <div id="M000931_source" class="dyn-source">
                        <pre>static VALUE
econv_inspect(VALUE self)
{
    const char *cname = rb_obj_classname(self);
    rb_econv_t *ec;

    TypedData_Get_Struct(self, rb_econv_t, &amp;econv_data_type, ec);
    if (!ec)
        return rb_sprintf(&quot;#&lt;%s: uninitialized&gt;&quot;, cname);
    else {
        const char *sname = ec-&gt;source_encoding_name;
        const char *dname = ec-&gt;destination_encoding_name;
        VALUE str;
        str = rb_sprintf(&quot;#&lt;%s: &quot;, cname);
        econv_description(sname, dname, ec-&gt;flags, str);
        rb_str_cat2(str, &quot;&gt;&quot;);
        return str;
    }
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000941">
                    
                    <a name="M000941"></a><b>ec.last_error &rarr; exception or nil
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns an exception object for the last conversion. Returns nil if the
last conversion did not produce an error.
</p>
<p>
&#8220;error&#8221; means that <a
href="InvalidByteSequenceError.html">Encoding::InvalidByteSequenceError</a>
and <a
href="UndefinedConversionError.html">Encoding::UndefinedConversionError</a>
for <a href="Converter.html#M000936">Encoding::Converter#convert</a> and
:invalid_byte_sequence, :incomplete_input and :undefined_conversion for <a
href="Converter.html#M000935">Encoding::Converter#primitive_convert</a>.
</p>
<pre>
 ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;iso-8859-1&quot;)
 p ec.primitive_convert(src=&quot;\xf1abcd&quot;, dst=&quot;&quot;)       #=&gt; :invalid_byte_sequence
 p ec.last_error      #=&gt; #&lt;Encoding::InvalidByteSequenceError: &quot;\xF1&quot; followed by &quot;a&quot; on UTF-8&gt;
 p ec.primitive_convert(src, dst, nil, 1)             #=&gt; :destination_buffer_full
 p ec.last_error      #=&gt; nil
</pre>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000941_source')" id="l_M000941_source">show</a>
                        
                    </p>
                    <div id="M000941_source" class="dyn-source">
                        <pre>static VALUE
econv_last_error(VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    VALUE exc;

    exc = make_econv_exception(ec);
    if (NIL_P(exc))
        return Qnil;
    return exc;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000935">
                    
                    <a name="M000935"></a><b>ec.primitive_convert(source_buffer, destination_buffer) &rarr; symbol
ec.primitive_convert(source_buffer, destination_buffer, destination_byteoffset) &rarr; symbol
ec.primitive_convert(source_buffer, destination_buffer, destination_byteoffset, destination_bytesize) &rarr; symbol
ec.primitive_convert(source_buffer, destination_buffer, destination_byteoffset, destination_bytesize, opt) &rarr; symbol
</b>
                    
                </div>
                
                <div class="description">
                  <p>
possible opt elements:
</p>
<pre>
  hash form:
    :partial_input =&gt; true           # source buffer may be part of larger source
    :after_output =&gt; true            # stop conversion after output before input
  integer form:
    Encoding::Converter::PARTIAL_INPUT
    Encoding::Converter::AFTER_OUTPUT
</pre>
<p>
possible results:
</p>
<pre>
   :invalid_byte_sequence
   :incomplete_input
   :undefined_conversion
   :after_output
   :destination_buffer_full
   :source_buffer_empty
   :finished
</pre>
<p>
<a href="Converter.html#M000935">primitive_convert</a> converts
source_buffer into destination_buffer.
</p>
<p>
source_buffer should be a string or nil. nil means a empty string.
</p>
<p>
destination_buffer should be a string.
</p>
<p>
destination_byteoffset should be an integer or nil. nil means the end of
destination_buffer. If it is omitted, nil is assumed.
</p>
<p>
destination_bytesize should be an integer or nil. nil means unlimited. If
it is omitted, nil is assumed.
</p>
<p>
opt should be nil, a hash or an integer. nil means no flags. If it is
omitted, nil is assumed.
</p>
<p>
<a href="Converter.html#M000935">primitive_convert</a> converts the content
of source_buffer from beginning and store the result into
destination_buffer.
</p>
<p>
destination_byteoffset and destination_bytesize specify the region which
the converted result is stored. destination_byteoffset specifies the start
position in destination_buffer in bytes. If destination_byteoffset is nil,
destination_buffer.bytesize is used for appending the result.
destination_bytesize specifies maximum number of bytes. If
destination_bytesize is nil, destination size is unlimited. After
conversion, destination_buffer is resized to destination_byteoffset +
actually produced number of bytes. Also destination_buffer&#8217;s encoding
is set to destination_encoding.
</p>
<p>
<a href="Converter.html#M000935">primitive_convert</a> drops the converted
part of source_buffer. the dropped part is converted in destination_buffer
or buffered in <a href="Converter.html">Encoding::Converter</a> object.
</p>
<p>
<a href="Converter.html#M000935">primitive_convert</a> stops conversion
when one of following condition met.
</p>
<ul>
<li>invalid byte sequence found in source buffer (:invalid_byte_sequence)

</li>
<li>unexpected end of source buffer (:incomplete_input) this occur only when
:partial_input is not specified.

</li>
<li>character not representable in output encoding (:undefined_conversion)

</li>
<li>after some output is generated, before input is done (:after_output) this
occur only when :after_output is specified.

</li>
<li>destination buffer is full (:destination_buffer_full) this occur only when
destination_bytesize is non-nil.

</li>
<li>source buffer is empty (:source_buffer_empty) this occur only when
:partial_input is specified.

</li>
<li>conversion is finished (:finished)

</li>
</ul>
<p>
example:
</p>
<pre>
  ec = Encoding::Converter.new(&quot;UTF-8&quot;, &quot;UTF-16BE&quot;)
  ret = ec.primitive_convert(src=&quot;pi&quot;, dst=&quot;&quot;, nil, 100)
  p [ret, src, dst] #=&gt; [:finished, &quot;&quot;, &quot;\x00p\x00i&quot;]

  ec = Encoding::Converter.new(&quot;UTF-8&quot;, &quot;UTF-16BE&quot;)
  ret = ec.primitive_convert(src=&quot;pi&quot;, dst=&quot;&quot;, nil, 1)
  p [ret, src, dst] #=&gt; [:destination_buffer_full, &quot;i&quot;, &quot;\x00&quot;]
  ret = ec.primitive_convert(src, dst=&quot;&quot;, nil, 1)
  p [ret, src, dst] #=&gt; [:destination_buffer_full, &quot;&quot;, &quot;p&quot;]
  ret = ec.primitive_convert(src, dst=&quot;&quot;, nil, 1)
  p [ret, src, dst] #=&gt; [:destination_buffer_full, &quot;&quot;, &quot;\x00&quot;]
  ret = ec.primitive_convert(src, dst=&quot;&quot;, nil, 1)
  p [ret, src, dst] #=&gt; [:finished, &quot;&quot;, &quot;i&quot;]
</pre>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000935_source')" id="l_M000935_source">show</a>
                        
                    </p>
                    <div id="M000935_source" class="dyn-source">
                        <pre>static VALUE
econv_primitive_convert(int argc, VALUE *argv, VALUE self)
{
    VALUE input, output, output_byteoffset_v, output_bytesize_v, opt, flags_v;
    rb_econv_t *ec = check_econv(self);
    rb_econv_result_t res;
    const unsigned char *ip, *is;
    unsigned char *op, *os;
    long output_byteoffset, output_bytesize;
    unsigned long output_byteend;
    int flags;

    rb_scan_args(argc, argv, &quot;23&quot;, &amp;input, &amp;output, &amp;output_byteoffset_v, &amp;output_bytesize_v, &amp;opt);

    if (NIL_P(output_byteoffset_v))
        output_byteoffset = 0; /* dummy */
    else
        output_byteoffset = NUM2LONG(output_byteoffset_v);

    if (NIL_P(output_bytesize_v))
        output_bytesize = 0; /* dummy */
    else
        output_bytesize = NUM2LONG(output_bytesize_v);

    if (NIL_P(opt)) {
        flags = 0;
    }
    else if (!NIL_P(flags_v = rb_check_to_integer(opt, &quot;to_int&quot;))) {
        flags = NUM2INT(flags_v);
    }
    else {
        VALUE v;
        opt = rb_convert_type(opt, T_HASH, &quot;Hash&quot;, &quot;to_hash&quot;);
        flags = 0;
        v = rb_hash_aref(opt, sym_partial_input);
        if (RTEST(v))
            flags |= ECONV_PARTIAL_INPUT;
        v = rb_hash_aref(opt, sym_after_output);
        if (RTEST(v))
            flags |= ECONV_AFTER_OUTPUT;
    }

    StringValue(output);
    if (!NIL_P(input))
        StringValue(input);
    rb_str_modify(output);

    if (NIL_P(output_bytesize_v)) {
        output_bytesize = RSTRING_EMBED_LEN_MAX;
        if (!NIL_P(input) &amp;&amp; output_bytesize &lt; RSTRING_LEN(input))
            output_bytesize = RSTRING_LEN(input);
    }

  retry:

    if (NIL_P(output_byteoffset_v))
        output_byteoffset = RSTRING_LEN(output);

    if (output_byteoffset &lt; 0)
        rb_raise(rb_eArgError, &quot;negative output_byteoffset&quot;);

    if (RSTRING_LEN(output) &lt; output_byteoffset)
        rb_raise(rb_eArgError, &quot;output_byteoffset too big&quot;);

    if (output_bytesize &lt; 0)
        rb_raise(rb_eArgError, &quot;negative output_bytesize&quot;);

    output_byteend = (unsigned long)output_byteoffset +
                     (unsigned long)output_bytesize;

    if (output_byteend &lt; (unsigned long)output_byteoffset ||
        LONG_MAX &lt; output_byteend)
        rb_raise(rb_eArgError, &quot;output_byteoffset+output_bytesize too big&quot;);

    if (rb_str_capacity(output) &lt; output_byteend)
        rb_str_resize(output, output_byteend);

    if (NIL_P(input)) {
        ip = is = NULL;
    }
    else {
        ip = (const unsigned char *)RSTRING_PTR(input);
        is = ip + RSTRING_LEN(input);
    }

    op = (unsigned char *)RSTRING_PTR(output) + output_byteoffset;
    os = op + output_bytesize;

    res = rb_econv_convert(ec, &amp;ip, is, &amp;op, os, flags);
    rb_str_set_len(output, op-(unsigned char *)RSTRING_PTR(output));
    if (!NIL_P(input))
        rb_str_drop_bytes(input, ip - (unsigned char *)RSTRING_PTR(input));

    if (NIL_P(output_bytesize_v) &amp;&amp; res == econv_destination_buffer_full) {
        if (LONG_MAX / 2 &lt; output_bytesize)
            rb_raise(rb_eArgError, &quot;too long conversion result&quot;);
        output_bytesize *= 2;
        output_byteoffset_v = Qnil;
        goto retry;
    }

    if (ec-&gt;destination_encoding) {
        rb_enc_associate(output, ec-&gt;destination_encoding);
    }

    return econv_result_to_symbol(res);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000938">
                    
                    <a name="M000938"></a><b>ec.primitive_errinfo &rarr; array
</b>
                    
                </div>
                
                <div class="description">
                  <p>
<a href="Converter.html#M000938">primitive_errinfo</a> returns important
information regarding the last error as a 5-element array:
</p>
<pre>
  [result, enc1, enc2, error_bytes, readagain_bytes]
</pre>
<p>
result is the last result of primitive_convert.
</p>
<p>
Other elements are only meaningful when result is :invalid_byte_sequence,
:incomplete_input or :undefined_conversion.
</p>
<p>
enc1 and enc2 indicate a conversion step as a pair of strings. For example,
a converter from EUC-JP to ISO-8859-1 converts a string as follows: EUC-JP
-> UTF-8 -> ISO-8859-1. So [enc1, enc2] is either [&#8220;EUC-JP&#8221;,
&#8220;UTF-8&#8221;] or [&#8220;UTF-8&#8221;, &#8220;ISO-8859-1&#8221;].
</p>
<p>
error_bytes and readagain_bytes indicate the byte sequences which caused
the error. error_bytes is discarded portion. readagain_bytes is buffered
portion which is read again on next conversion.
</p>
<p>
Example:
</p>
<pre>
  # \xff is invalid as EUC-JP.
  ec = Encoding::Converter.new(&quot;EUC-JP&quot;, &quot;Shift_JIS&quot;)
  ec.primitive_convert(src=&quot;\xff&quot;, dst=&quot;&quot;, nil, 10)
  p ec.primitive_errinfo
  #=&gt; [:invalid_byte_sequence, &quot;EUC-JP&quot;, &quot;UTF-8&quot;, &quot;\xFF&quot;, &quot;&quot;]

  # HIRAGANA LETTER A (\xa4\xa2 in EUC-JP) is not representable in ISO-8859-1.
  # Since this error is occur in UTF-8 to ISO-8859-1 conversion,
  # error_bytes is HIRAGANA LETTER A in UTF-8 (\xE3\x81\x82).
  ec = Encoding::Converter.new(&quot;EUC-JP&quot;, &quot;ISO-8859-1&quot;)
  ec.primitive_convert(src=&quot;\xa4\xa2&quot;, dst=&quot;&quot;, nil, 10)
  p ec.primitive_errinfo
  #=&gt; [:undefined_conversion, &quot;UTF-8&quot;, &quot;ISO-8859-1&quot;, &quot;\xE3\x81\x82&quot;, &quot;&quot;]

  # partial character is invalid
  ec = Encoding::Converter.new(&quot;EUC-JP&quot;, &quot;ISO-8859-1&quot;)
  ec.primitive_convert(src=&quot;\xa4&quot;, dst=&quot;&quot;, nil, 10)
  p ec.primitive_errinfo
  #=&gt; [:incomplete_input, &quot;EUC-JP&quot;, &quot;UTF-8&quot;, &quot;\xA4&quot;, &quot;&quot;]

  # Encoding::Converter::PARTIAL_INPUT prevents invalid errors by
  # partial characters.
  ec = Encoding::Converter.new(&quot;EUC-JP&quot;, &quot;ISO-8859-1&quot;)
  ec.primitive_convert(src=&quot;\xa4&quot;, dst=&quot;&quot;, nil, 10, Encoding::Converter::PARTIAL_INPUT)
  p ec.primitive_errinfo
  #=&gt; [:source_buffer_empty, nil, nil, nil, nil]

  # \xd8\x00\x00@ is invalid as UTF-16BE because
  # no low surrogate after high surrogate (\xd8\x00).
  # It is detected by 3rd byte (\00) which is part of next character.
  # So the high surrogate (\xd8\x00) is discarded and
  # the 3rd byte is read again later.
  # Since the byte is buffered in ec, it is dropped from src.
  ec = Encoding::Converter.new(&quot;UTF-16BE&quot;, &quot;UTF-8&quot;)
  ec.primitive_convert(src=&quot;\xd8\x00\x00@&quot;, dst=&quot;&quot;, nil, 10)
  p ec.primitive_errinfo
  #=&gt; [:invalid_byte_sequence, &quot;UTF-16BE&quot;, &quot;UTF-8&quot;, &quot;\xD8\x00&quot;, &quot;\x00&quot;]
  p src
  #=&gt; &quot;@&quot;

  # Similar to UTF-16BE, \x00\xd8@\x00 is invalid as UTF-16LE.
  # The problem is detected by 4th byte.
  ec = Encoding::Converter.new(&quot;UTF-16LE&quot;, &quot;UTF-8&quot;)
  ec.primitive_convert(src=&quot;\x00\xd8@\x00&quot;, dst=&quot;&quot;, nil, 10)
  p ec.primitive_errinfo
  #=&gt; [:invalid_byte_sequence, &quot;UTF-16LE&quot;, &quot;UTF-8&quot;, &quot;\x00\xD8&quot;, &quot;@\x00&quot;]
  p src
  #=&gt; &quot;&quot;
</pre>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000938_source')" id="l_M000938_source">show</a>
                        
                    </p>
                    <div id="M000938_source" class="dyn-source">
                        <pre>static VALUE
econv_primitive_errinfo(VALUE self)
{
    rb_econv_t *ec = check_econv(self);

    VALUE ary;

    ary = rb_ary_new2(5);

    rb_ary_store(ary, 0, econv_result_to_symbol(ec-&gt;last_error.result));
    rb_ary_store(ary, 4, Qnil);

    if (ec-&gt;last_error.source_encoding)
        rb_ary_store(ary, 1, rb_str_new2(ec-&gt;last_error.source_encoding));

    if (ec-&gt;last_error.destination_encoding)
        rb_ary_store(ary, 2, rb_str_new2(ec-&gt;last_error.destination_encoding));

    if (ec-&gt;last_error.error_bytes_start) {
        rb_ary_store(ary, 3, rb_str_new((const char *)ec-&gt;last_error.error_bytes_start, ec-&gt;last_error.error_bytes_len));
        rb_ary_store(ary, 4, rb_str_new((const char *)ec-&gt;last_error.error_bytes_start + ec-&gt;last_error.error_bytes_len, ec-&gt;last_error.readagain_len));
    }

    return ary;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000940">
                    
                    <a name="M000940"></a><b>putback</b>(...)
                    
                </div>
                
                <div class="description">
                  <p>
call-seq
</p>
<pre>
  ec.putback                    -&gt; string
  ec.putback(max_numbytes)      -&gt; string
</pre>
<p>
Put back the bytes which will be converted.
</p>
<p>
The bytes are caused by invalid_byte_sequence error. When
invalid_byte_sequence error, some bytes are discarded and some bytes are
buffered to be converted later. The latter bytes can be put back. It can be
observed by <a
href="InvalidByteSequenceError.html#M000954">Encoding::InvalidByteSequenceError#readagain_bytes</a>
and <a
href="Converter.html#M000938">Encoding::Converter#primitive_errinfo</a>.
</p>
<pre>
  ec = Encoding::Converter.new(&quot;utf-16le&quot;, &quot;iso-8859-1&quot;)
  src = &quot;\x00\xd8\x61\x00&quot;
  dst = &quot;&quot;
  p ec.primitive_convert(src, dst)   #=&gt; :invalid_byte_sequence
  p ec.primitive_errinfo     #=&gt; [:invalid_byte_sequence, &quot;UTF-16LE&quot;, &quot;UTF-8&quot;, &quot;\x00\xD8&quot;, &quot;a\x00&quot;]
  p ec.putback               #=&gt; &quot;a\x00&quot;
  p ec.putback               #=&gt; &quot;&quot;          # no more bytes to put back
</pre>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000940_source')" id="l_M000940_source">show</a>
                        
                    </p>
                    <div id="M000940_source" class="dyn-source">
                        <pre>static VALUE
econv_putback(int argc, VALUE *argv, VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    int n;
    int putbackable;
    VALUE str, max;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;max);

    if (NIL_P(max))
        n = rb_econv_putbackable(ec);
    else {
        n = NUM2INT(max);
        putbackable = rb_econv_putbackable(ec);
        if (putbackable &lt; n)
            n = putbackable;
    }

    str = rb_str_new(NULL, n);
    rb_econv_putback(ec, (unsigned char *)RSTRING_PTR(str), n);

    if (ec-&gt;source_encoding) {
        rb_enc_associate(str, ec-&gt;source_encoding);
    }

    return str;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000942">
                    
                    <a name="M000942"></a><b>ec.replacement &rarr; string
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns the replacement string.
</p>
<pre>
 ec = Encoding::Converter.new(&quot;euc-jp&quot;, &quot;us-ascii&quot;)
 p ec.replacement    #=&gt; &quot;?&quot;

 ec = Encoding::Converter.new(&quot;euc-jp&quot;, &quot;utf-8&quot;)
 p ec.replacement    #=&gt; &quot;\uFFFD&quot;
</pre>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000942_source')" id="l_M000942_source">show</a>
                        
                    </p>
                    <div id="M000942_source" class="dyn-source">
                        <pre>static VALUE
econv_get_replacement(VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    int ret;
    rb_encoding *enc;

    ret = make_replacement(ec);
    if (ret == -1) {
        rb_raise(rb_eUndefinedConversionError, &quot;replacement character setup failed&quot;);
    }

    enc = rb_enc_find(ec-&gt;replacement_enc);
    return rb_enc_str_new((const char *)ec-&gt;replacement_str, (long)ec-&gt;replacement_len, enc);
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000943">
                    
                    <a name="M000943"></a><b>ec.replacement = string
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Sets the replacement string.
</p>
<pre>
 ec = Encoding::Converter.new(&quot;utf-8&quot;, &quot;us-ascii&quot;, :undef =&gt; :replace)
 ec.replacement = &quot;&lt;undef&gt;&quot;
 p ec.convert(&quot;a \u3042 b&quot;)      #=&gt; &quot;a &lt;undef&gt; b&quot;
</pre>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000943_source')" id="l_M000943_source">show</a>
                        
                    </p>
                    <div id="M000943_source" class="dyn-source">
                        <pre>static VALUE
econv_set_replacement(VALUE self, VALUE arg)
{
    rb_econv_t *ec = check_econv(self);
    VALUE string = arg;
    int ret;
    rb_encoding *enc;

    StringValue(string);
    enc = rb_enc_get(string);

    ret = rb_econv_set_replacement(ec,
            (const unsigned char *)RSTRING_PTR(string),
            RSTRING_LEN(string),
            rb_enc_name(enc));

    if (ret == -1) {
        /* xxx: rb_eInvalidByteSequenceError? */
        rb_raise(rb_eUndefinedConversionError, &quot;replacement character setup failed&quot;);
    }

    return arg;
}</pre>
                    </div>
                </div>
                
            </div>
            
            <div class="method">
                <div class="title" id="M000933">
                    
                    <a name="M000933"></a><b>ec.source_encoding &rarr; encoding
</b>
                    
                </div>
                
                <div class="description">
                  <p>
Returns the source encoding as an <a href="../Encoding.html">Encoding</a>
object.
</p>

                </div>
                
                
                
                
                <div class="sourcecode">
                    <p class="source-link">
                        Source: <a href="javascript:toggleSource('M000933_source')" id="l_M000933_source">show</a>
                        
                    </p>
                    <div id="M000933_source" class="dyn-source">
                        <pre>static VALUE
econv_source_encoding(VALUE self)
{
    rb_econv_t *ec = check_econv(self);
    if (!ec-&gt;source_encoding)
        return Qnil;
    return rb_enc_from_encoding(ec-&gt;source_encoding);
}</pre>
                    </div>
                </div>
                
            </div>
            
</div>
    </div>
  </body>
</html>    